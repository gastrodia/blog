---
author: gastrodia
pubDatetime: 2025-12-24T14:30:00Z
title: ä½¿ç”¨Service Workerå®ç°èµ„æºç¼“å­˜åŠ é€Ÿ
slug: p28
featured: true
draft: false
tags:
  - Service Worker
  - JavaScript
ogImage: ""
description: é€šè¿‡ Service Worker å®ç° Cache First ç­–ç•¥ï¼Œæ™ºèƒ½ç¼“å­˜æ¥è‡ªèµ„æº çš„å¤§æ–‡ä»¶èµ„æºï¼Œå¤§å¹…æå‡åŠ è½½é€Ÿåº¦ï¼Œæ”¯æŒç¦»çº¿è®¿é—®ï¼Œé™ä½ç½‘ç»œæµé‡æ¶ˆè€—ã€‚
---

åœ¨å¼€å‘ Web åº”ç”¨æ—¶ï¼ŒæŸäº›ä½“ç§¯å¤§ä¸”ä¸æ˜“å˜åŒ–çš„èµ„æºï¼š

- UI æ¡†æ¶ï¼ˆReact, Vue å®Œæ•´ç‰ˆï¼‰
- æ•°æ®å¯è§†åŒ–åº“ï¼ˆD3.js, Three.js ç­‰ï¼‰
- WebAssembly æ¨¡å—

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Service Workeræ¥ç¼“å­˜è¿™äº›æ–‡ä»¶ã€‚

## Service Workerå·¥ä½œæµç¨‹

Service Worker æ˜¯è¿è¡Œåœ¨æµè§ˆå™¨åå°çš„ JavaScript è„šæœ¬ï¼Œå®ƒç‹¬ç«‹äºç½‘é¡µã€‚

![Service Worker](/assets/images/28/1.svg)

## Service Worker ç”Ÿå‘½å‘¨æœŸ
```text
1. æ³¨å†Œï¼ˆRegisterï¼‰
   â†“
   navigator.serviceWorker.register('/sw.js')
   
2. å®‰è£…ï¼ˆInstallï¼‰
   â†“
   install äº‹ä»¶è§¦å‘
   â”œâ”€â”€ å¯é€‰ï¼šé¢„ç¼“å­˜èµ„æº
   â””â”€â”€ self.skipWaiting() - è·³è¿‡ç­‰å¾…
   
3. æ¿€æ´»ï¼ˆActivateï¼‰
   â†“
   activate äº‹ä»¶è§¦å‘
   â”œâ”€â”€ æ¸…ç†æ—§ç¼“å­˜
   â””â”€â”€ self.clients.claim() - ç«‹å³æ¥ç®¡é¡µé¢
   
4. å·¥ä½œï¼ˆFetchï¼‰
   â†“
   fetch äº‹ä»¶è§¦å‘
   â””â”€â”€ æ‹¦æˆªè¯·æ±‚ï¼Œè¿”å›ç¼“å­˜æˆ–ç½‘ç»œèµ„æº
   
5. æ›´æ–°ï¼ˆUpdateï¼‰
   â†“
   æ£€æµ‹åˆ° sw.js å˜åŒ–æ—¶é‡æ–°å®‰è£…
```

## sw.jså®Œæ•´å®ç°
```javascript file="sw.js"

// ç¼“å­˜ç­–ç•¥ï¼šCache First (ç¼“å­˜ä¼˜å…ˆï¼Œé€‚åˆä¸ç»å¸¸å˜åŒ–çš„å¤§æ–‡ä»¶)
const CACHE_NAME = 'cache-v1';

// éœ€è¦ç¼“å­˜çš„èµ„æº åˆ—è¡¨ï¼ˆå¯ä»¥æ˜¯åŸŸåæˆ– URL æ¨¡å¼ï¼‰
const CACHE_PATTERNS = [
    'cdn.jsdelivr.net/npm/pyodide',
    // å¯ä»¥æ·»åŠ æ›´å¤šèµ„æºï¼Œä¾‹å¦‚ï¼š
    // 'unpkg.com',
    // 'cdnjs.cloudflare.com',
    // 'cdn.bootcdn.net',
];

// å®‰è£… Service Worker
self.addEventListener('install', (event) => {
    console.log('[SW] Service Worker: Installing...');
    // è·³è¿‡ç­‰å¾…ï¼Œç«‹å³æ¿€æ´»
    self.skipWaiting();
    
    // ä¸é¢„ç¼“å­˜ï¼Œç­‰é¦–æ¬¡ä½¿ç”¨æ—¶å†ç¼“å­˜ï¼Œé¿å…é¦–æ¬¡åŠ è½½è¿‡æ…¢
    event.waitUntil(Promise.resolve());
});

// æ¿€æ´» Service Worker
self.addEventListener('activate', (event) => {
    console.log('[SW] Service Worker: Activating...');
    
    event.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => {
                    // æ¸…ç†æ—§ç¼“å­˜
                    if (cacheName !== CACHE_NAME) {
                        console.log('[SW] Clearing old cache:', cacheName);
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => {
            console.log('[SW] Service Worker activated and ready!');
            // ç«‹å³æ¥ç®¡æ‰€æœ‰é¡µé¢
            return self.clients.claim();
        })
    );
});

// æ‹¦æˆªç½‘ç»œè¯·æ±‚ - Cache First ç­–ç•¥ï¼ˆä¼˜å…ˆä½¿ç”¨ç¼“å­˜ï¼‰
self.addEventListener('fetch', (event) => {
    const url = event.request.url;
    
    const shouldCache = CACHE_PATTERNS.some(pattern => url.includes(pattern));
    
    if (shouldCache) {
        console.log('[SW] ğŸ¯ æ‹¦æˆªè¯·æ±‚:', url.split('/').pop(), '| ç±»å‹:', event.request.destination || 'unknown');
        
        event.respondWith(
            (async () => {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    
                    // ä½¿ç”¨ ignoreSearch: true æ¥å¿½ç•¥ URL å‚æ•°å·®å¼‚
                    // ä½¿ç”¨ ignoreVary: true æ¥å¿½ç•¥ Vary å¤´éƒ¨å·®å¼‚
                    const cacheOptions = {
                        ignoreSearch: true,
                        ignoreVary: true
                    };
                    
                    // å…ˆæŸ¥è¯¢ç¼“å­˜
                    let cachedResponse = await cache.match(event.request, cacheOptions);
                    
                    // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•ç”¨ URL å­—ç¬¦ä¸²ç›´æ¥åŒ¹é…
                    if (!cachedResponse) {
                        cachedResponse = await cache.match(url, cacheOptions);
                    }
                    
                    if (cachedResponse) {
                        // æœ‰ç¼“å­˜ï¼Œç«‹å³è¿”å›
                        console.log('[SW] âœ“ ä»ç¼“å­˜è¿”å›:', url.split('/').pop());
                        return cachedResponse;
                    }
                    
                    // æ— ç¼“å­˜ï¼Œä»ç½‘ç»œè·å–
                    console.log('[SW] â¬‡ ä»ç½‘ç»œä¸‹è½½:', url.split('/').pop());
                    const response = await fetch(event.request);
                    
                    // æ£€æŸ¥å“åº”æ˜¯å¦æœ‰æ•ˆ
                    // å…è®¸ç¼“å­˜ï¼šstatus 200-299 æˆ– opaque response (status 0)
                    const shouldCache = response && (
                        (response.status >= 200 && response.status < 300) ||
                        response.type === 'opaque'
                    );
                    
                    if (shouldCache) {
                        // å…‹éš†å“åº”å¹¶ç¼“å­˜
                        const responseToCache = response.clone();
                        
                        try {
                            // ä½¿ç”¨ URL ä½œä¸ºç¼“å­˜é”®ï¼Œæ›´ç¨³å®š
                            await cache.put(url, responseToCache);
                            console.log('[SW] âœ“ å·²ç¼“å­˜:', url.split('/').pop(), 
                                       '| ç±»å‹:', response.type, 
                                       '| çŠ¶æ€:', response.status);
                            
                            // éªŒè¯æ˜¯å¦çœŸçš„ç¼“å­˜æˆåŠŸ
                            const verify = await cache.match(url, cacheOptions);
                            if (verify) {
                                console.log('[SW] âœ“ ç¼“å­˜éªŒè¯æˆåŠŸ:', url.split('/').pop());
                            } else {
                                console.error('[SW] âœ— ç¼“å­˜éªŒè¯å¤±è´¥:', url.split('/').pop());
                            }
                        } catch (cacheError) {
                            console.error('[SW] âœ— ç¼“å­˜å¤±è´¥:', url.split('/').pop(), cacheError);
                        }
                    } else {
                        console.warn('[SW] âš  å“åº”æ— æ•ˆï¼Œæœªç¼“å­˜:', url.split('/').pop(), 
                                   '| çŠ¶æ€:', response?.status, 
                                   '| ç±»å‹:', response?.type);
                    }
                    
                    return response;
                } catch (error) {
                    console.error('[SW] âœ— è¯·æ±‚å¤±è´¥:', error);
                    // å°è¯•è¿”å›ç¼“å­˜ï¼ˆç¦»çº¿æƒ…å†µï¼‰
                    const cachedResponse = await caches.match(event.request);
                    if (cachedResponse) {
                        console.log('[SW] âœ“ ä½¿ç”¨ç¦»çº¿ç¼“å­˜:', url.split('/').pop());
                        return cachedResponse;
                    }
                    throw error;
                }
            })()
        );
    }
});

// ç›‘å¬æ¶ˆæ¯ï¼Œæ”¯æŒæ‰‹åŠ¨æ¸…ç†ç¼“å­˜
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'CLEAR_CACHE') {
        event.waitUntil(
            caches.delete(CACHE_NAME).then(() => {
                console.log('Service Worker: Cache cleared');
                event.ports[0].postMessage({ success: true });
            })
        );
    }
    
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});
```


## åœ¨é¡¹ç›®ä¸­ä½¿ç”¨sw.js
```javascript file="main.js"
async function registerServiceWorker() {
    if (!('serviceWorker' in navigator)) {
        console.warn('[Main] å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Service Worker');
        return false;
    }
    
    try {
        // å…ˆæµ‹è¯• sw.js æ˜¯å¦å¯è®¿é—®
        const swPath = '/sw.js';
        try {
            const testResponse = await fetch(swPath, { method: 'HEAD' });
            if (!testResponse.ok) {
                console.error('[Main] âœ— æ— æ³•è®¿é—® sw.js æ–‡ä»¶ï¼ŒHTTP çŠ¶æ€:', testResponse.status);
                console.error('[Main] è¯·ç¡®ä¿ sw.js åœ¨ç½‘ç«™æ ¹ç›®å½•');
                return false;
            }
        } catch (fetchError) {
            console.error('[Main] âœ— æ— æ³•è®¿é—® sw.js æ–‡ä»¶:', fetchError.message);
            console.error('[Main] è¯·åœ¨æµè§ˆå™¨ä¸­è®¿é—®', window.location.origin + swPath, 'æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨');
            return false;
        }
        
        console.log('[Main] â³ æ­£åœ¨æ³¨å†Œ Service Worker...');
        const registration = await navigator.serviceWorker.register(swPath, {
            scope: '/'
        });
        
        console.log('[Main] âœ“ Service Worker æ³¨å†ŒæˆåŠŸ:', registration);
        
        // ç­‰å¾… Service Worker æ¿€æ´»
        await navigator.serviceWorker.ready;
        console.log('[Main] âœ“ Service Worker å·²å°±ç»ª');
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ controllerï¼ˆé¡µé¢æ˜¯å¦è¢« Service Worker æ¥ç®¡ï¼‰
        if (navigator.serviceWorker.controller) {
            this.serviceWorkerReady = true;
            console.log('[Main] âœ“ Service Worker å·²æ¥ç®¡é¡µé¢ï¼Œèµ„æºå°†ä»ç¼“å­˜åŠ è½½');
        } else {
            // é¦–æ¬¡è®¿é—®ï¼ŒService Worker å°šæœªæ¥ç®¡é¡µé¢
            // è¿™æ˜¯æ­£å¸¸çš„ï¼Œéœ€è¦åˆ·æ–°é¡µé¢åæ‰èƒ½å¯ç”¨ç¼“å­˜
            this.serviceWorkerReady = false;
            console.log('[Main] â„¹ Service Worker å·²æ³¨å†Œä½†æœªæ¥ç®¡å½“å‰é¡µé¢');
        }
        
        return true;
    } catch (error) {
        console.error('[Main] âœ— Service Worker æ³¨å†Œå¤±è´¥:', error);
        return false;
    }
}
```

## æ¸…ç†ç¼“å­˜
```javascript
async function clearCache() {
    try {
        const registration = await navigator.serviceWorker.ready;
        const messageChannel = new MessageChannel();
        
        return new Promise((resolve) => {
            messageChannel.port1.onmessage = (event) => {
                if (event.data.success) {
                    console.log('âœ“ CDN ç¼“å­˜å·²æ¸…ç†');
                    resolve(true);
                }
            };
            
            registration.active.postMessage(
                { type: 'CLEAR_CACHE' },
                [messageChannel.port2]
            );
        });
    } catch (error) {
        console.error('æ¸…ç†ç¼“å­˜å¤±è´¥:', error);
        return false;
    }
}

```

## æŸ¥çœ‹ç¼“å­˜çš„èµ„æº
```javascript
async getCacheInfo() {
    try {
        const cache = await caches.open('cache-v1'); // æ³¨æ„è¿™é‡Œçš„è¦ä¸sw.jsçš„CACHE_NAMEä¸€è‡´
        const keys = await cache.keys();
        
        console.log('=== Pyodide ç¼“å­˜çŠ¶æ€ ===');
        console.log(`å…±ç¼“å­˜ ${keys.length} ä¸ªæ–‡ä»¶ï¼š`);
        
        let totalSize = 0;
        let opaqueCount = 0;
        for (const request of keys) {
            const response = await cache.match(request);
            if (response) {
                const blob = await response.blob();
                const size = blob.size;
                totalSize += size;
                
                // æ ¹æ®æ–‡ä»¶å¤§å°é€‰æ‹©åˆé€‚çš„å•ä½
                let sizeStr;
                if (size === 0) {
                    // å¯¹äº 0 å­—èŠ‚ï¼Œå°è¯•ä» Content-Length è·å–çœŸå®å¤§å°
                    const contentLength = response.headers.get('content-length');
                    if (contentLength) {
                        const realSize = parseInt(contentLength);
                        if (realSize > 0) {
                            if (realSize < 1024) {
                                sizeStr = `${realSize} å­—èŠ‚ (opaque)`;
                            } else if (realSize < 1024 * 1024) {
                                sizeStr = `${(realSize / 1024).toFixed(2)} KB (opaque)`;
                            } else {
                                sizeStr = `${(realSize / 1024 / 1024).toFixed(2)} MB (opaque)`;
                            }
                        } else {
                            sizeStr = '0 å­—èŠ‚ âš ï¸';
                        }
                    } else {
                        // æ— æ³•è·å–å¤§å°ï¼Œå¯èƒ½æ˜¯ opaque å“åº”ï¼ˆè·¨åŸŸè¯·æ±‚çš„æ­£å¸¸ç°è±¡ï¼‰
                        sizeStr = `å·²ç¼“å­˜ âœ“ (opaque)`;
                        opaqueCount++;
                    }
                } else if (size < 1024) {
                    sizeStr = `${size} å­—èŠ‚`;  // å°äº1KBæ˜¾ç¤ºå­—èŠ‚
                } else if (size < 1024 * 1024) {
                    sizeStr = `${(size / 1024).toFixed(2)} KB`;  // å°äº1MBæ˜¾ç¤ºKB
                } else {
                    sizeStr = `${(size / 1024 / 1024).toFixed(2)} MB`;  // å¤§äº1MBæ˜¾ç¤ºMB
                }
                
                console.log(`  âœ“ ${request.url.split('/').pop()} (${sizeStr})`);
            }
        }
        
        console.log(`æ€»å¤§å°: ${(totalSize / 1024 / 1024).toFixed(2)} MB${opaqueCount > 0 ? ` (ä¸å« ${opaqueCount} ä¸ª opaque æ–‡ä»¶)` : ''}`);
        console.log('========================');
        
        return {
            count: keys.length,
            totalSize: totalSize,
            files: keys.map(k => k.url)
        };
    } catch (error) {
        console.error('è·å–ç¼“å­˜ä¿¡æ¯å¤±è´¥:', error);
        return null;
    }
}
```

## ç¤ºä¾‹
![](/assets/images/28/2.png)