---
author: gastrodia
pubDatetime: 2024-12-10T18:39:00Z
title: Bun + WebRTC æ‰“é€ å®æ—¶ç›´æ’­å¹³å°ï¼šä»ä¿¡ä»¤æœåŠ¡åˆ°å±å¹•å…±äº«
slug: p23
featured: true
draft: false
tags:
  - Bun
  - WebRTC
ogImage: ""
description: ä½¿ç”¨ Bun æ„å»º WebSocket ä¿¡ä»¤æœåŠ¡å™¨ï¼Œç»“åˆ WebRTC æŠ€æœ¯å®ç°å±å¹•å…±äº«ç›´æ’­ã€å¼¹å¹•äº’åŠ¨ç­‰åŠŸèƒ½ï¼Œå®Œæ•´çš„ P2P è§†é¢‘æµä¼ è¾“è§£å†³æ–¹æ¡ˆã€‚
---

è¿‘æ—¥ã€‚å­¦ä¹  BUN ä¸­ï¼Œçªå‘å¥‡æƒ³ï¼Œå¦‚ä½•å®ç°ä¸€ä¸ªç›´æ’­å¹³å°ï¼Ÿ

## ![image](/assets/images/23/1.png)

### 0. BUN çš„å®‰è£…

[å®‰è£… BUN](https://bun.sh/docs/installation)

### 1. åˆå§‹åŒ–é¡¹ç›®

```sh
bun init
```

### 2. å®ç° serve ä¿¡ä»¤æœåŠ¡å™¨

> index.ts

```typescript
import Bun from "bun";
import type { ServerWebSocket } from "bun";

type MessageKeys =
  | "join"
  | "create"
  | "offer"
  | "answer"
  | "icecandidate"
  | "error"
  | "success"
  | "leave"
  | "close"
  | "joined"
  | "danmaku"
  | "updateRooms";

class Share {
  constructor() {}

  port = 3000;

  messageHandlers: Partial<
    Record<
      MessageKeys,
      (ws: ServerWebSocket<string>, payload: Record<string, any>) => void
    >
  > = {
    join: (ws, payload) => {
      // æœ‰ç”¨æˆ·åŠ å…¥æˆ¿é—´
      const { roomId, userId, username } = payload;

      this.users.set(userId, {
        ws,
        name: username,
        roomId,
      });

      if (!roomId) return;

      const room = this.rooms.get(roomId);

      if (!room) {
        this.sendMessage(ws, "error", {
          message: "æˆ¿é—´ä¸å­˜åœ¨æˆ–å·²å…³é—­",
        });
        return;
      }

      this.users.set(userId, {
        ws,
        name: username,
        roomId,
      });

      room.clients.push(ws);

      this.sendMessage(room.host, "joined", {
        userId,
        username,
      });

      this.sendMessage(ws, "success", {
        message: `åŠ å…¥æˆ¿é—´ ${room.name} æˆåŠŸ`,
      });
    },
    create: (ws, payload) => {
      const { roomId, roomName, cover } = payload;
      this.rooms.set(roomId, {
        host: ws,
        name: roomName,
        cover,
        clients: [],
      });

      // é€šçŸ¥æ‰€æœ‰ç”¨æˆ· æœ‰æ–°æˆ¿é—´
      for (const [userId, user] of this.users) {
        const { ws: userWs } = user;
        this.sendMessage(userWs, "updateRooms", {
          roomId,
          type: "create",
        });
      }
    },
    offer: (ws, payload) => {
      const { offer, userId, roomId } = payload;
      const user = this.users.get(userId);
      if (!user) {
        this.sendMessage(ws, "error", {
          message: "ç”¨æˆ·ä¸å­˜åœ¨",
        });
        return;
      }
      const { ws: userWs } = user;
      this.sendMessage(userWs, "offer", {
        offer,
        userId,
        roomId,
      });
    },
    answer: (ws, payload) => {
      const { answer, userId, roomId } = payload;
      const room = this.rooms.get(roomId);
      if (!room) {
        this.sendMessage(ws, "error", {
          message: "æˆ¿é—´ä¸å­˜åœ¨",
        });
        return;
      }
      this.sendMessage(room.host, "answer", {
        answer,
        userId,
        roomId,
      });
    },
    icecandidate: (ws, payload) => {
      const { candidate, userId, roomId } = payload;
      const user = this.users.get(userId);
      if (!user) {
        this.sendMessage(ws, "error", {
          message: "ç”¨æˆ·ä¸å­˜åœ¨",
        });
        return;
      }
      const { ws: userWs } = user;
      this.sendMessage(userWs, "icecandidate", {
        candidate,
        userId,
        roomId,
      });
    },
    danmaku: (ws, payload) => {
      const { roomId, admin, message, username, userId } = payload;
      const room = this.rooms.get(roomId);
      if (!room) {
        this.sendMessage(ws, "error", {
          message: "æˆ¿é—´ä¸å­˜åœ¨æˆ–å·²å…³é—­",
        });
        return;
      }
      const vo = {
        admin,
        message,
        username,
        userId,
      };
      for (const client of room.clients) {
        this.sendMessage(client, "danmaku", vo);
      }
      const { host } = room;
      this.sendMessage(host, "danmaku", vo);
    },
  };

  rooms = new Map<
    string,
    {
      host: ServerWebSocket<string>;
      name: string;
      cover: string;
      clients: ServerWebSocket<string>[];
    }
  >(); // æˆ¿é—´
  users = new Map<
    string,
    {
      name: string;
      ws: ServerWebSocket<string>;
      roomId: string;
    }
  >(); // ç”¨æˆ·

  get roomData() {
    const data = [];
    for (const [roomId, room] of this.rooms) {
      data.push({
        id: roomId,
        name: room.name,
        cover: room.cover,
      });
    }
    return data;
  }

  sendMessage(
    ws: ServerWebSocket<string>,
    type: MessageKeys,
    data: Record<string, any>
  ) {
    ws.send(
      JSON.stringify({
        type,
        data,
      })
    );
  }

  async start() {
    Bun.serve<string>({
      port: this.port,
      fetch: async (request, server) => {
        const path = new URL(request.url).pathname;
        if (path === "/") {
          const file = Bun.file("./src/index.html");
          const exists = await file.exists();
          if (exists) return new Response(file);
        }
        if (path === "/ws") {
          const success = server.upgrade(request);
          if (success) return new Response("Upgrading...");
        }
        if (path.startsWith("/src/")) {
          const filePath = path.replace("/src/", "./src/");
          const file = Bun.file(filePath);
          const exists = await file.exists();
          if (exists) return new Response(file);
        } else if (path.startsWith("/api/")) {
          if (path === "/api/rooms") {
            return new Response(JSON.stringify(this.roomData));
          }
        }
        return new Response(path);
      },
      websocket: {
        open() {},
        close: (ws, code, reason) => {
          // ç”¨æˆ·ç¦»å¼€ æˆ–è€… å…³é—­æˆ¿é—´
          // åˆ¤æ–­æ˜¯ç”¨æˆ·ç¦»å¼€è¿˜æ˜¯å…³é—­æˆ¿é—´
          // 1. å¦‚æœä»ç”¨æˆ·åˆ—è¡¨ä¸­æ‰¾åˆ°ç”¨æˆ·ï¼Œè¯´æ˜æ˜¯ç”¨æˆ·ç¦»å¼€ åˆ™éœ€è¦é€šçŸ¥æˆ¿é—´å†…çš„å…¶ä»–ç”¨æˆ· å’Œ æˆ¿ä¸»
          // 2. å¦‚æœä»æˆ¿é—´åˆ—è¡¨ä¸­æ‰¾åˆ°æˆ¿é—´ï¼Œè¯´æ˜æ˜¯æˆ¿ä¸»å…³é—­æˆ¿é—´ï¼Œåˆ™éœ€è¦é€šçŸ¥æˆ¿é—´å†…çš„å…¶ä»–ç”¨æˆ·
          const user = Array.from(this.users).find(
            ([userId, user]) => user.ws === ws
          );
          if (user) {
            const [userId, { ws, roomId, name }] = user;
            const room = this.rooms.get(roomId);
            if (room) {
              this.sendMessage(room.host, "leave", {
                userId,
                username: name,
                message: `ç”¨æˆ· ${name}(${userId}) ç¦»å¼€äº†æˆ¿é—´`,
              });
              room.clients = room.clients.filter(client => client !== ws);
            }
            this.users.delete(userId);
            return;
          }

          const room = Array.from(this.rooms).find(
            ([roomId, room]) => room.host === ws
          );
          if (room) {
            const [roomId, { name, clients }] = room;
            for (const client of clients) {
              this.sendMessage(client, "close", {
                roomId,
                roomName: name,
                message: `æˆ¿é—´ ${name}(${roomId}) å·²å…³é—­`,
              });
            }
            this.rooms.delete(roomId);

            // é€šçŸ¥æ‰€æœ‰ç”¨æˆ· æœ‰æˆ¿é—´å…³é—­
            for (const [userId, user] of this.users) {
              const { ws: userWs } = user;
              this.sendMessage(userWs, "updateRooms", {
                roomId,
                type: "close",
              });
            }
          }
        },
        message: (ws, message: string) => {
          const payload: {
            type: MessageKeys;
            data: Record<string, any>;
          } = JSON.parse(message);
          const { type, data } = payload;

          const handler = this.messageHandlers[type];
          handler?.(ws, data);
        },
      },
    });
    console.log(`bun server is running at http://localhost:${this.port}`);
  }
}

const share = new Share();
await share.start();
```

### 3. å®ç°ä¸»æ’­é¡µé¢

> æ ¹ç›®å½•ä¸‹æ–°å»º src æ–‡ä»¶å¤¹ï¼›src æ–‡ä»¶å¤¹ä¸‹æ–°å»º main.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
      }

      .container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .header {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        border-bottom: 1px solid #ccc;
        align-items: center;
      }

      .header h1 {
        margin: 0;
      }

      .header-main {
        flex: 1;
      }

      .header-main button {
        padding: 5px 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      .main {
        margin-top: 10px;
        flex: 1;
        display: flex;
        overflow: hidden;
      }

      #preview {
        flex: 1;
        border: 1px solid #ccc;
        overflow: hidden;
      }

      .message {
        width: 300px;
        border: 1px solid #ccc;
        margin: 0 0 0 10px;
        padding: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .message-list {
        padding: 0 0 0 24px;
        margin: 0;
        flex: 1;
        overflow-y: auto;
      }

      #danmaku {
        display: flex;
        padding: 10px;
        border-top: 1px solid #ccc;
      }

      #danmaku input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      #danmaku button {
        padding: 5px 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 id="title"></h1>
        <div class="header-main">
          <button id="button">å¼€å§‹å…±äº«</button>
          <button id="share-link">åˆ†äº«æˆ¿é—´</button>
        </div>
      </div>
      <div class="main">
        <video id="preview"></video>
        <div class="message">
          <ul class="message-list"></ul>
          <form id="danmaku">
            <input type="text" placeholder="è¯·è¾“å…¥æ¶ˆæ¯" />
            <button type="submit">å‘é€</button>
          </form>
        </div>
      </div>
    </div>
  </body>
  <script>
    class Main {
      constructor() {
        const params = new URLSearchParams(location.search);
        const url = new URL(location.href);
        this.preview = document.getElementById("preview");
        this.socketUrl = `ws://${url.host}/ws`;
        this.title = document.getElementById("title");
        this.button = document.getElementById("button");
        this.shareButton = document.getElementById("share-link");
        this.messageContainer = document.querySelector(".message-list");
        this.socket = null;
        this.roomId = params.get("id") || this.generateClientId();
        this.roomName = params.get("name") || "";
        this.isSharing = false;
        this.stream = null;
        this.peers = new Map();
        this.cover = "";
        this.danmaku = document.getElementById("danmaku");
      }

      start() {
        this.inputRoomName();
        this.registerEvent();
      }

      messageHandler = {
        joined: async data => {
          console.log("join");
          const li = document.createElement("li");
          li.textContent = `æ¬¢è¿ ${data.username}(${data.userId}) åŠ å…¥æˆ¿é—´`;
          this.setMessage(li);

          // ç»™æ–°åŠ å…¥çš„ç”¨æˆ·å‘é€offer
          const peer = new RTCPeerConnection();
          this.stream
            .getTracks()
            .forEach(track => peer.addTrack(track, this.stream));
          peer.onicecandidate = e => {
            if (e.candidate) {
              this.sendMessage("icecandidate", {
                candidate: e.candidate,
                userId: data.userId,
                roomId: this.roomId,
              });
            }
          };

          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          this.sendMessage("offer", {
            offer,
            userId: data.userId,
            roomId: this.roomId,
          });

          this.peers.set(data.userId, peer);
        },
        leave: data => {
          console.log("leave");
          const li = document.createElement("li");
          li.classList.add("leave");
          li.textContent = `${data.username}(${data.userId}) ç¦»å¼€æˆ¿é—´`;
          this.setMessage(li);
        },
        answer: async data => {
          console.log("answer");
          const { answer, userId } = data;
          const peer = this.peers.get(userId);
          await peer.setRemoteDescription(answer);
        },
        icecandidate: data => {
          console.log("icecandidate");
          const { candidate, userId } = data;
          const peer = this.peers.get(userId);
          peer.addIceCandidate(new RTCIceCandidate(candidate));
        },
        danmaku: data => {
          const li = document.createElement("li");
          const possessor = document.createElement("label");
          const { roomId, admin, message, username, userId } = data;
          let part = "";
          if (admin) part = "æˆ‘";
          else part = `${username}(${userId})`;
          possessor.textContent = `${part}è¯´ï¼š`;
          const content = document.createElement("span");
          content.textContent = message;
          li.appendChild(possessor);
          li.appendChild(content);
          this.setMessage(li);
        },
      };

      sendMessage(type, data) {
        this.socket.send(
          JSON.stringify({
            type,
            data,
          })
        );
      }

      generateClientId() {
        return Math.random().toString().substring(2, 9);
      }

      inputRoomName() {
        while (!this.roomName) {
          this.roomName = prompt("è¯·è¾“å…¥");
        }
        this.title.textContent = `hi, ${this.roomName}(${this.roomId})`;
        const params = new URLSearchParams({
          id: this.roomId,
          name: this.roomName,
        });
        history.pushState(null, "", `?${params}`);
      }

      registerEvent() {
        this.button.addEventListener("click", this.buttonClick.bind(this));
        this.danmaku.addEventListener("submit", this.danmakuSubmit.bind(this));
        this.shareButton.addEventListener("click", () => {
          const url = new URL(`${location.origin}/src/watch.html`);
          url.searchParams.set("id", this.roomId);
          url.searchParams.set("name", this.roomName);
          navigator.clipboard.writeText(url.href);
        });
      }

      async buttonClick() {
        this.isSharing ? await this.stopShare() : await this.startShare();
      }

      async stopShare() {
        if (!this.stream) return;
        this.stream.getTracks().forEach(track => track.stop());
        this.stream = null;
        await this.preview.pause();
        this.preview.srcObject = null;
        this.socket?.close();
        this.socket = null;
        this.peers.forEach(peer => peer.close());
        this.peers.clear();

        const li = document.createElement("li");
        li.textContent = `æˆ¿é—´ ${this.roomName}(${this.roomId}) å·²å…³é—­`;
        this.setMessage(li);

        this.isSharing = false;
        this.button.textContent = "å¼€å§‹å…±äº«";
      }

      async startShare() {
        this.stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: false,
        });

        this.stream.getTracks().forEach(track => {
          track.onended = this.stopShare.bind(this);
        });

        this.preview.srcObject = this.stream;
        await this.preview.play();

        // è·å–ç¬¬ä¸€å¸§ä½œä¸ºå°é¢
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = this.preview.videoWidth;
        canvas.height = this.preview.videoHeight;
        ctx.drawImage(this.preview, 0, 0, canvas.width, canvas.height);
        this.cover = canvas.toDataURL("image/png");

        this.socket = new WebSocket(this.socketUrl);
        this.socket.onopen = this.socketOnOpen.bind(this);
        this.socket.onmessage = this.socketOnMessage.bind(this);
        this.socket.onerror = this.socketOnError.bind(this);
        this.socket.onclose = this.socketOnClose.bind(this);

        const li = document.createElement("li");
        li.textContent = `æˆ¿é—´ ${this.roomName}(${this.roomId}) å·²åˆ›å»º`;
        this.setMessage(li);

        this.isSharing = true;
        this.button.textContent = "åœæ­¢å…±äº«";
      }

      socketOnOpen() {
        this.sendMessage("create", {
          roomId: this.roomId,
          roomName: this.roomName,
          cover: this.cover,
        });
      }

      socketOnMessage(e) {
        const payload = JSON.parse(e.data);
        const { data, type } = payload;
        this.messageHandler[type](data);
      }

      socketOnError() {}

      socketOnClose() {
        this.stopShare();
      }

      setMessage(li) {
        this.messageContainer.appendChild(li);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
      }

      danmakuSubmit(e) {
        e.preventDefault();
        if (!this.socket) return;
        const input = this.danmaku.querySelector("input");
        const message = input.value;
        if (!message) return;
        this.sendMessage("danmaku", {
          message,
          roomId: this.roomId,
          admin: true,
        });
        input.value = "";
      }
    }

    const main = new Main();
    main.start();
  </script>
</html>
```

### 4. å®ç°è§‚ä¼—é¡µé¢

> /src/watch.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
      }
      .container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .header {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        border-bottom: 1px solid #ccc;
        align-items: center;
      }

      .header h1 {
        margin: 0;
      }

      .main {
        margin-top: 10px;
        flex: 1;
        display: flex;
        overflow: hidden;
      }

      #preview {
        flex: 1;
        border: 1px solid #ccc;
        overflow: hidden;
      }

      .message {
        width: 300px;
        border: 1px solid #ccc;
        margin: 0 0 0 10px;
        padding: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .message-list {
        padding: 0 0 0 24px;
        margin: 0;
        flex: 1;
        overflow-y: auto;
      }

      #danmaku {
        display: flex;
        padding: 10px;
        border-top: 1px solid #ccc;
      }

      #danmaku input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      #danmaku button {
        padding: 5px 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-left: 10px;
      }

      .room-list {
        padding: 0;
        list-style: none;
        width: 300px;
        border: 1px solid #ccc;
        margin: 0 10px 0 0;
      }

      .room-list li {
        padding: 10px;
        border-bottom: 1px solid #ccc;
      }

      .room-list li img {
        width: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 id="title"></h1>
      </div>
      <div class="main">
        <ul class="room-list"></ul>
        <video id="preview"></video>
        <div class="message">
          <ul class="message-list"></ul>
          <form id="danmaku">
            <input type="text" placeholder="è¯·è¾“å…¥æ¶ˆæ¯" />
            <button type="submit">å‘é€</button>
          </form>
        </div>
      </div>
    </div>
    <script>
      class Watch {
        constructor() {
          const params = new URLSearchParams(location.search);
          const url = new URL(location.href);
          this.video = document.getElementById("preview");
          this.title = document.getElementById("title");
          this.messageContainer = document.querySelector(".message-list");
          this.socket = null;
          this.socketUrl = `ws://${url.host}/ws`;
          this.roomContainer = document.querySelector(".room-list");
          this.peer = null;
          this.username = params.get("uname");
          this.userId = params.get("uid") || this.generateClientId();
          this.danmaku = document.getElementById("danmaku");
        }

        get roomId() {
          const params = new URLSearchParams(location.search);
          return params.get("id");
        }

        set roomId(value) {
          const params = new URLSearchParams(location.search);
          params.set("id", value);
          history.pushState(null, "", `?${params}`);
        }

        messageHandler = {
          offer: async data => {
            const { offer } = data;
            await this.peer.setRemoteDescription(offer);
            const answer = await this.peer.createAnswer();
            await this.peer.setLocalDescription(answer);
            this.sendMessage("answer", {
              answer,
              userId: this.userId,
              roomId: this.roomId,
            });
          },
          answer: data => {
            console.log(data);
          },
          error: e => {
            const li = document.createElement("li");
            li.textContent = e.message;
            this.setMessage(li);
          },
          success: e => {
            const li = document.createElement("li");
            li.textContent = e.message;
            this.setMessage(li);
          },
          close: e => {
            const li = document.createElement("li");
            li.textContent = e.message;
            this.setMessage(li);

            this.video.srcObject?.getTracks().forEach(track => track.stop());
            this.peer.close();
          },
          icecandidate: async data => {
            await this.peer.addIceCandidate(data.candidate);
          },
          updateRooms: data => {
            this.getRoom();
            const { type, roomId } = data;
            if (type === "create" && roomId === this.roomId) {
              this.enterRoom();
            }
          },
          danmaku: data => {
            const li = document.createElement("li");
            const possessor = document.createElement("label");
            const { roomId, admin, message, username, userId } = data;
            let part = "";
            if (admin) part = "UPä¸»";
            else if (userId === this.userId) part = "æˆ‘";
            else part = `${username}(${userId})`;
            possessor.textContent = `${part}è¯´ï¼š`;
            const content = document.createElement("span");
            content.textContent = message;
            li.appendChild(possessor);
            li.appendChild(content);
            this.setMessage(li);
          },
        };

        async start() {
          this.inputUsername();
          this.registerEvent();
          await this.getRoom();
          await this.enterRoom();
        }

        setMessage(li) {
          this.messageContainer.appendChild(li);
          this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        }
        generateClientId() {
          return Math.random().toString().substring(2, 9);
        }

        inputUsername() {
          while (!this.username) {
            this.username = prompt("è¯·è¾“å…¥ç”¨æˆ·å");
          }
          this.title.textContent = `hi, ${this.username}(${this.userId})`;
          const params = new URLSearchParams(location.search);
          params.set("uid", this.userId);
          params.set("uname", this.username);
          history.pushState(null, "", `?${params}`);
        }

        async getRoom() {
          const res = await fetch("/api/rooms");
          const rooms = await res.json();
          this.roomContainer.innerHTML = "";
          const fragment = document.createDocumentFragment();
          for (const room of rooms) {
            const li = document.createElement("li");
            const a = document.createElement("a");
            const params = new URLSearchParams({
              id: room.id,
              uid: this.userId,
              uname: this.username,
            });

            const cover = document.createElement("img");
            cover.src = room.cover;
            a.href = `?${params}`;
            a.textContent = `${room.name}(${room.id})çš„æˆ¿é—´`;
            li.appendChild(cover);
            li.appendChild(a);
            fragment.appendChild(li);
          }
          this.roomContainer.appendChild(fragment);
        }

        async enterRoom() {
          // if (!this.roomId) return
          this.socket = new WebSocket(this.socketUrl);
          this.peer = new RTCPeerConnection();
          this.peer.ontrack = e => {
            this.video.srcObject = e.streams[0];
            this.video.play().catch(this.play.bind(this));
          };

          this.peer.onicecandidate = e => {
            if (e.candidate) {
              this.sendMessage("icecandidate", {
                candidate: e.candidate,
                userId: this.userId,
                roomId: this.roomId,
              });
            }
          };
          this.socket.onopen = this.socketOnOpen.bind(this);
          this.socket.onmessage = this.socketOnMessage.bind(this);
          this.socket.onerror = this.socketOnError.bind(this);
        }

        // æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾
        play() {
          const li = document.createElement("li");
          li.style.color = "red";
          const span = document.createElement("span");
          span.textContent = "ç”±äºæµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾ç­–ç•¥ï¼Œ";
          const a = document.createElement("a");
          a.href = "javascript:void(0)";
          a.textContent = "ç‚¹å‡»è¿™é‡Œæ’­æ”¾";
          a.onclick = () => {
            this.video.play();
            li.remove();
          };
          li.appendChild(span);
          li.appendChild(a);
          this.setMessage(li);
        }

        socketOnOpen() {
          this.sendMessage("join", {
            roomId: this.roomId,
            userId: this.userId,
            username: this.username,
          });
        }

        socketOnMessage(e) {
          const payload = JSON.parse(e.data);
          const { data, type } = payload;
          this.messageHandler[type](data);
        }

        sendMessage(type, data) {
          this.socket.send(
            JSON.stringify({
              type,
              data,
            })
          );
        }

        socketOnError() {
          this.video.srcObject?.getTracks().forEach(track => track.stop());
          this.peer.close();
        }

        registerEvent() {
          this.danmaku.addEventListener(
            "submit",
            this.danmakuSubmit.bind(this)
          );
        }

        danmakuSubmit(e) {
          e.preventDefault();
          if (!this.socket) return;
          const input = this.danmaku.querySelector("input");
          const message = input.value;
          if (!message) return;
          this.sendMessage("danmaku", {
            message,
            roomId: this.roomId,
            username: this.username,
            userId: this.userId,
          });
          input.value = "";
        }
      }

      const watch = new Watch();
      watch.start();
    </script>
  </body>
</html>
```

### 5. å…¥å£

> /src/index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <style>
      a {
        display: block;
        width: 100%;
        height: 100px;
        line-height: 100px;
        text-align: center;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 24px;
        font-family: Arial, sans-serif;
        text-decoration: none;
      }

      a + a {
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div>
      <a href="/src/main.html">æˆ‘è¦åˆ†äº«</a>
      <a href="/src/watch.html">æˆ‘è¦è§‚çœ‹</a>
    </div>
  </body>
</html>
```

### 6. è¿è¡Œ

```shell
bun run ./index.ts
```

ğŸ¥° ğŸ¥° ğŸ¥°
