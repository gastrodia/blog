---
interface Props {
  file: string;
  fileName?: string;
}

const { file, fileName } = Astro.props;
---

<div class="relative w-full">
  <div id="pdf-loading">
    <slot name="fallback"></slot>
  </div>
  <div
    id="pdf-canvas-container"
    class="w-full"
    data-pdf-url={file}
    data-pdf-name={fileName}
  >
  </div>
</div>

<script>
  import * as pdfjsLib from "pdfjs-dist";
  import type { PDFDocumentProxy, PDFPageProxy, RenderTask } from "pdfjs-dist";

  const WORKER_SRC = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;
  const CONTAINER_PADDING = 0;
  const DEFAULT_CONTAINER_WIDTH = 800;
  const RESIZE_DEBOUNCE_DELAY = 300;

  pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_SRC;

  class PDFViewer {
    private container: HTMLElement | null = null;
    private loading: HTMLElement | null = null;
    private resizeTimeout?: ReturnType<typeof setTimeout>;
    private currentRenderTasks: RenderTask[] = [];
    private isRendering = false;
    private lastWidth = 0; // 记录上次宽度，用于判断是否真正需要重新渲染
    private cachedPdf: PDFDocumentProxy | null = null; // 缓存 PDF 文档避免重复加载
    private currentPdfUrl: string | null = null; // 记录当前 PDF URL，用于检测是否需要重新加载

    constructor() {
      this.container = document.getElementById("pdf-canvas-container");
      this.loading = document.getElementById("pdf-loading");
      this.lastWidth = window.innerWidth;
    }

    async init(): Promise<void> {
      if (!this.container) return;

      const pdfUrl = this.container.getAttribute("data-pdf-url");
      if (!pdfUrl) return;

      // Prevent concurrent rendering
      if (this.isRendering) {
        return;
      }

      this.isRendering = true;

      try {
        this.cancelCurrentRenders();

        // 检测 PDF URL 是否改变（页面切换场景）
        const isPdfChanged = this.currentPdfUrl !== pdfUrl;
        if (isPdfChanged && this.cachedPdf) {
          // 释放旧的 PDF 资源
          this.cachedPdf.destroy();
          this.cachedPdf = null;
        }
        this.currentPdfUrl = pdfUrl;

        // 首次加载或 PDF 改变时才清空容器，resize 时使用双缓冲
        const isFirstLoad = !this.cachedPdf;
        if (isFirstLoad) {
          this.clearContainer();
        }

        const pdf = this.cachedPdf || await this.loadPDF(pdfUrl);
        this.cachedPdf = pdf;

        if (isFirstLoad) {
          // 首次加载直接渲染到容器
          await this.renderAllPages(pdf);
        } else {
          // resize 时使用双缓冲：先渲染到临时容器，完成后再替换
          await this.renderAllPagesWithDoubleBuffer(pdf);
        }
        
        this.hideLoading();
      } catch (error) {
        this.handleError(error, pdfUrl);
      } finally {
        this.isRendering = false;
      }
    }

    // 清理资源，用于页面切换前
    destroy(): void {
      this.cancelCurrentRenders();
      clearTimeout(this.resizeTimeout);
      if (this.cachedPdf) {
        this.cachedPdf.destroy();
        this.cachedPdf = null;
      }
      this.currentPdfUrl = null;
    }

    private async loadPDF(url: string): Promise<PDFDocumentProxy> {
      const loadingTask = pdfjsLib.getDocument(url);
      return await loadingTask.promise;
    }

    private async renderAllPages(pdf: PDFDocumentProxy): Promise<void> {
      // Render pages sequentially to avoid race conditions
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        await this.renderPage(pdf, pageNum, this.container!);
      }
    }

    // 双缓冲渲染：先渲染到 DocumentFragment，完成后一次性替换
    private async renderAllPagesWithDoubleBuffer(pdf: PDFDocumentProxy): Promise<void> {
      const fragment = document.createDocumentFragment();
      const tempContainer = document.createElement("div");
      
      // 临时容器需要有宽度才能正确计算 viewport
      tempContainer.style.width = `${this.container?.clientWidth || DEFAULT_CONTAINER_WIDTH}px`;
      
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        await this.renderPage(pdf, pageNum, tempContainer);
      }
      
      // 将渲染好的 canvas 移动到 fragment
      while (tempContainer.firstChild) {
        fragment.appendChild(tempContainer.firstChild);
      }
      
      // 一次性替换：先清空再添加，最小化 DOM 操作
      this.clearContainer();
      this.container?.appendChild(fragment);
    }

    private async renderPage(
      pdf: PDFDocumentProxy,
      pageNum: number,
      targetContainer: HTMLElement | DocumentFragment
    ): Promise<void> {
      if (!this.container) return;

      const page = await pdf.getPage(pageNum);
      const canvas = this.createCanvas(page);

      if (!canvas) return;

      const context = canvas.getContext("2d");
      if (!context) return;

      const viewport = this.calculateViewport(page);
      
      // 获取设备像素比，用于高清屏幕渲染
      const pixelRatio = window.devicePixelRatio || 1;
      
      // 设置canvas的实际像素尺寸（考虑设备像素比）
      canvas.width = Math.floor(viewport.width * pixelRatio);
      canvas.height = Math.floor(viewport.height * pixelRatio);
      
      // 设置canvas的CSS显示尺寸
      canvas.style.width = `${viewport.width}px`;
      canvas.style.height = `${viewport.height}px`;
      
      // 缩放context以匹配设备像素比
      context.scale(pixelRatio, pixelRatio);

      const renderTask = page.render({
        canvasContext: context,
        viewport: viewport,
      } as any);

      this.currentRenderTasks.push(renderTask);

      try {
        await renderTask.promise;
        targetContainer.appendChild(canvas);
      } catch (error) {
        if ((error as Error).name !== "RenderingCancelledException") {
          throw error;
        }
      }
    }

    private createCanvas(_page: PDFPageProxy): HTMLCanvasElement {
      return document.createElement("canvas");
    }

    private calculateViewport(page: PDFPageProxy) {
      const containerWidth =
        this.container?.clientWidth || DEFAULT_CONTAINER_WIDTH;
      const baseViewport = page.getViewport({ scale: 1 });
      const scale = (containerWidth - CONTAINER_PADDING) / baseViewport.width;
      return page.getViewport({ scale });
    }

    private clearContainer(): void {
      if (this.container) {
        this.container.innerHTML = "";
      }
    }

    private cancelCurrentRenders(): void {
      this.currentRenderTasks.forEach(task => task.cancel());
      this.currentRenderTasks = [];
    }

    private hideLoading(): void {
      if (!this.loading) return;

      if (this.loading && this.loading.parentNode) {
        this.loading.parentNode.removeChild(this.loading);
      }
    }

    private handleError(error: unknown, pdfUrl: string): void {
      console.error("Error loading PDF:", error);

      if (this.container) {
        this.container.innerHTML = `
          <div class="p-8 text-center">
            <p class="text-red-500 mb-4">Failed to load PDF</p>
            <a href="${pdfUrl}" download class="text-blue-500 underline hover:text-blue-600">
              Download PDF
            </a>
          </div>
        `;
      }

      if (this.loading) {
        this.loading.style.display = "none";
      }
    }

    handleResize = (): void => {
      // 只在宽度真正变化时才重新渲染（避免移动端滚动时地址栏隐藏/虚拟键盘触发的resize）
      const currentWidth = window.innerWidth;
      if (currentWidth === this.lastWidth) return;
      
      this.lastWidth = currentWidth;
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.init(), RESIZE_DEBOUNCE_DELAY);
    };

  }

  // Initialize PDF viewer (singleton pattern)
  let viewer: PDFViewer | null = null;
  let currentResizeHandler: (() => void) | null = null;

  function initViewer() {
    // 清理旧的 viewer 和事件监听器
    if (viewer) {
      viewer.destroy();
    }
    if (currentResizeHandler) {
      window.removeEventListener("resize", currentResizeHandler);
    }

    // 创建新的 viewer 实例
    viewer = new PDFViewer();
    viewer.init();

    // 更新 resize 监听器指向新的 viewer
    currentResizeHandler = viewer.handleResize;
    window.addEventListener("resize", currentResizeHandler);
  }

  // Handle Astro page transitions
  document.addEventListener("astro:page-load", initViewer);
</script>
