---
interface Props {
  file: string;
  fileName?: string;
}

const { file, fileName } = Astro.props;
---

<div class="relative w-full">
  <div id="pdf-loading">
    <slot name="fallback"></slot>
  </div>
  <div
    id="pdf-canvas-container"
    class="w-full"
    data-pdf-url={file}
    data-pdf-name={fileName}
  >
  </div>
</div>

<style is:global>
  /* PDF 页面容器样式 */
  .pdf-page {
    position: relative;
    margin-bottom: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .pdf-page canvas {
    display: block;
    width: 100%;
    height: auto;
  }

  /* 确保文本层可以选中 */
  .textLayer {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    line-height: 1;
    user-select: text;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
  }

  .textLayer > span {
    color: transparent;
    position: absolute;
    white-space: pre;
    cursor: text;
    transform-origin: 0% 0%;
    line-height: 1;
    display: inline-block;
    pointer-events: auto;
  }

  .textLayer ::selection {
    background: rgba(0, 100, 255, 0.4);
  }

  /* 调试模式：取消注释以显示文本层 */
  /* .textLayer > span {
    color: rgba(255, 0, 0, 0.5) !important;
  } */

  /* 注释层样式 */
  .annotationLayer {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
  }

  .annotationLayer section {
    position: absolute;
    pointer-events: auto;
  }

  .annotationLayer .linkAnnotation > a,
  .annotationLayer .buttonWidgetAnnotation.pushButton > a {
    position: absolute;
    font-size: 1em;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }

  .annotationLayer .linkAnnotation > a:hover,
  .annotationLayer .buttonWidgetAnnotation.pushButton > a:hover {
    opacity: 0.2;
    background: rgba(255, 255, 0, 1);
    box-shadow: 0px 2px 10px rgba(255, 255, 0, 1);
  }

  /* 其他注释样式 */
  .annotationLayer .textAnnotation img {
    cursor: pointer;
  }
</style>

<script>
  import * as pdfjsLib from "pdfjs-dist";
  import type { PDFDocumentProxy, PDFPageProxy, RenderTask } from "pdfjs-dist";

  const WORKER_SRC = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;
  const PDF_VIEWER_CSS = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/web/pdf_viewer.css`;
  const CONTAINER_PADDING = 0;
  const DEFAULT_CONTAINER_WIDTH = 800;
  const RESIZE_DEBOUNCE_DELAY = 300;

  pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_SRC;

  // 动态加载 PDF.js 的 CSS 样式
  function loadPdfViewerCSS() {
    const existingLink = document.querySelector('link[href*="pdf_viewer.css"]');
    if (!existingLink) {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = PDF_VIEWER_CSS;
      document.head.appendChild(link);
    }
  }

  // 在初始化时加载 CSS
  loadPdfViewerCSS();

  class PDFViewer {
    private container: HTMLElement | null = null;
    private loading: HTMLElement | null = null;
    private resizeTimeout?: ReturnType<typeof setTimeout>;
    private currentRenderTasks: RenderTask[] = [];
    private isRendering = false;
    private lastWidth = 0; // 记录上次宽度，用于判断是否真正需要重新渲染
    private cachedPdf: PDFDocumentProxy | null = null; // 缓存 PDF 文档避免重复加载
    private currentPdfUrl: string | null = null; // 记录当前 PDF URL，用于检测是否需要重新加载

    constructor() {
      this.container = document.getElementById("pdf-canvas-container");
      this.loading = document.getElementById("pdf-loading");
      this.lastWidth = window.innerWidth;
    }

    async init(): Promise<void> {
      if (!this.container) return;

      const pdfUrl = this.container.getAttribute("data-pdf-url");
      if (!pdfUrl) return;

      // Prevent concurrent rendering
      if (this.isRendering) {
        return;
      }

      this.isRendering = true;

      try {
        this.cancelCurrentRenders();

        // 检测 PDF URL 是否改变（页面切换场景）
        const isPdfChanged = this.currentPdfUrl !== pdfUrl;
        if (isPdfChanged && this.cachedPdf) {
          // 释放旧的 PDF 资源
          this.cachedPdf.destroy();
          this.cachedPdf = null;
        }
        this.currentPdfUrl = pdfUrl;

        // 首次加载或 PDF 改变时才清空容器，resize 时使用双缓冲
        const isFirstLoad = !this.cachedPdf;
        if (isFirstLoad) {
          this.clearContainer();
        }

        const pdf = this.cachedPdf || await this.loadPDF(pdfUrl);
        this.cachedPdf = pdf;

        if (isFirstLoad) {
          // 首次加载直接渲染到容器
          await this.renderAllPages(pdf);
        } else {
          // resize 时使用双缓冲：先渲染到临时容器，完成后再替换
          await this.renderAllPagesWithDoubleBuffer(pdf);
        }
        
        this.hideLoading();
      } catch (error) {
        this.handleError(error, pdfUrl);
      } finally {
        this.isRendering = false;
      }
    }

    // 清理资源，用于页面切换前
    destroy(): void {
      this.cancelCurrentRenders();
      clearTimeout(this.resizeTimeout);
      if (this.cachedPdf) {
        this.cachedPdf.destroy();
        this.cachedPdf = null;
      }
      this.currentPdfUrl = null;
    }

    private async loadPDF(url: string): Promise<PDFDocumentProxy> {
      const loadingTask = pdfjsLib.getDocument(url);
      return await loadingTask.promise;
    }

    private async renderAllPages(pdf: PDFDocumentProxy): Promise<void> {
      // Render pages sequentially to avoid race conditions
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        await this.renderPage(pdf, pageNum, this.container!);
      }
    }

    // 双缓冲渲染：先渲染到 DocumentFragment，完成后一次性替换
    private async renderAllPagesWithDoubleBuffer(pdf: PDFDocumentProxy): Promise<void> {
      const fragment = document.createDocumentFragment();
      const tempContainer = document.createElement("div");
      
      // 临时容器需要有宽度才能正确计算 viewport
      tempContainer.style.width = `${this.container?.clientWidth || DEFAULT_CONTAINER_WIDTH}px`;
      
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        await this.renderPage(pdf, pageNum, tempContainer);
      }
      
      // 将渲染好的 canvas 移动到 fragment
      while (tempContainer.firstChild) {
        fragment.appendChild(tempContainer.firstChild);
      }
      
      // 一次性替换：先清空再添加，最小化 DOM 操作
      this.clearContainer();
      this.container?.appendChild(fragment);
    }

    private async renderPage(
      pdf: PDFDocumentProxy,
      pageNum: number,
      targetContainer: HTMLElement | DocumentFragment
    ): Promise<void> {
      if (!this.container) return;

      const page = await pdf.getPage(pageNum);
      const viewport = this.calculateViewport(page);
      
      // 创建页面容器
      const pageContainer = document.createElement("div");
      pageContainer.className = "pdf-page";
      pageContainer.style.width = `${viewport.width}px`;
      pageContainer.style.height = `${viewport.height}px`;

      // 创建并渲染 Canvas
      const canvas = this.createCanvas();
      if (!canvas) return;

      const context = canvas.getContext("2d");
      if (!context) return;
      
      // 获取设备像素比，用于高清屏幕渲染
      const pixelRatio = window.devicePixelRatio || 1;
      
      // 设置canvas的实际像素尺寸（考虑设备像素比）
      canvas.width = Math.floor(viewport.width * pixelRatio);
      canvas.height = Math.floor(viewport.height * pixelRatio);
      
      // 设置canvas的CSS显示尺寸
      canvas.style.width = `${viewport.width}px`;
      canvas.style.height = `${viewport.height}px`;
      
      // 缩放context以匹配设备像素比
      context.scale(pixelRatio, pixelRatio);

      const renderTask = page.render({
        canvasContext: context,
        viewport: viewport,
        canvas: canvas,
      });

      this.currentRenderTasks.push(renderTask);

      try {
        await renderTask.promise;
        pageContainer.appendChild(canvas);

        // 渲染文本层（支持文本选择）
        await this.renderTextLayer(page, viewport, pageContainer);

        // 渲染注释层（支持链接点击）
        await this.renderAnnotationLayer(page, viewport, pageContainer);

        targetContainer.appendChild(pageContainer);
      } catch (error) {
        if ((error as Error).name !== "RenderingCancelledException") {
          throw error;
        }
      }
    }

    private async renderTextLayer(
      page: PDFPageProxy,
      viewport: ReturnType<PDFPageProxy['getViewport']>,
      pageContainer: HTMLElement
    ): Promise<void> {
      try {
        const textContent = await page.getTextContent();
        
        const textLayerDiv = document.createElement("div");
        textLayerDiv.className = "textLayer";

        // 渲染文本层内容
        const textContentItems = textContent.items;
        const scale = viewport.scale;
        
        for (const item of textContentItems) {
          if ('str' in item && item.str) {
            const textSpan = document.createElement("span");
            const tx = item.transform;
            
            // transform 矩阵: [scaleX, skewY, skewX, scaleY, translateX, translateY]
            // 直接使用 transform 值进行缩放
            const fontSize = Math.hypot(tx[2], tx[3]); // 计算 y 方向的缩放（字体高度）
            const fontScaleX = Math.hypot(tx[0], tx[1]) / fontSize; // x 方向的缩放比例
            
            // 计算角度
            const angle = Math.atan2(tx[1], tx[0]);
            
            // 使用 viewport 转换坐标
            // PDF 坐标原点在左下，需要转换为左上
            const x = tx[4] * scale;
            const y = (viewport.viewBox[3] - tx[5]) * scale;
            
            // 设置样式
            textSpan.style.left = `${x}px`;
            textSpan.style.top = `${y - fontSize * scale}px`; // 减去字体高度以对齐基线
            textSpan.style.fontSize = `${fontSize * scale}px`;
            textSpan.style.fontFamily = item.fontName || 'sans-serif';
            
            // 应用变换
            const transforms = [];
            if (Math.abs(fontScaleX - 1) > 0.001) {
              transforms.push(`scaleX(${fontScaleX})`);
            }
            if (Math.abs(angle) > 0.001) {
              transforms.push(`rotate(${angle}rad)`);
            }
            if (transforms.length > 0) {
              textSpan.style.transform = transforms.join(' ');
            }
            
            textSpan.textContent = item.str;
            textLayerDiv.appendChild(textSpan);
          }
        }

        pageContainer.appendChild(textLayerDiv);
      } catch (error: unknown) {
        // 文本层渲染失败不影响主要功能
        if (error instanceof Error) {
          // eslint-disable-next-line no-console
          console.warn("Text layer rendering failed:", error.message);
        }
      }
    }

    private async renderAnnotationLayer(
      page: PDFPageProxy,
      viewport: ReturnType<PDFPageProxy['getViewport']>,
      pageContainer: HTMLElement
    ): Promise<void> {
      try {
        const annotations = await page.getAnnotations();
        
        if (annotations.length === 0) return;

        const annotationLayerDiv = document.createElement("div");
        annotationLayerDiv.className = "annotationLayer";
        annotationLayerDiv.style.width = `${viewport.width}px`;
        annotationLayerDiv.style.height = `${viewport.height}px`;

        // 手动渲染链接注释
        for (const annotation of annotations) {
          if (annotation.subtype === 'Link' && annotation.url) {
            const linkSection = document.createElement("section");
            linkSection.className = "linkAnnotation";
            
            // 计算链接的位置和大小
            const rect = annotation.rect;
            if (rect && rect.length === 4) {
              const [x1, y1, x2, y2] = rect;
              
              // PDF 坐标系转换为 canvas 坐标系
              const [vx1, vy1] = viewport.convertToViewportPoint(x1, y1);
              const [vx2, vy2] = viewport.convertToViewportPoint(x2, y2);
              
              linkSection.style.left = `${Math.min(vx1, vx2)}px`;
              linkSection.style.top = `${Math.min(vy1, vy2)}px`;
              linkSection.style.width = `${Math.abs(vx2 - vx1)}px`;
              linkSection.style.height = `${Math.abs(vy2 - vy1)}px`;
            }
            
            const link = document.createElement("a");
            link.href = annotation.url;
            link.target = annotation.newWindow ? "_blank" : "_self";
            link.rel = "noopener noreferrer nofollow";
            link.title = annotation.url;
            
            linkSection.appendChild(link);
            annotationLayerDiv.appendChild(linkSection);
          }
        }

        if (annotationLayerDiv.children.length > 0) {
          pageContainer.appendChild(annotationLayerDiv);
        }
      } catch (error: unknown) {
        // 注释层渲染失败不影响主要功能
        if (error instanceof Error) {
          // eslint-disable-next-line no-console
          console.warn("Annotation layer rendering failed:", error.message);
        }
      }
    }

    private createCanvas(): HTMLCanvasElement {
      return document.createElement("canvas");
    }

    private calculateViewport(page: PDFPageProxy) {
      const containerWidth =
        this.container?.clientWidth || DEFAULT_CONTAINER_WIDTH;
      const baseViewport = page.getViewport({ scale: 1 });
      const scale = (containerWidth - CONTAINER_PADDING) / baseViewport.width;
      return page.getViewport({ scale });
    }

    private clearContainer(): void {
      if (this.container) {
        this.container.innerHTML = "";
      }
    }

    private cancelCurrentRenders(): void {
      this.currentRenderTasks.forEach(task => task.cancel());
      this.currentRenderTasks = [];
    }

    private hideLoading(): void {
      if (!this.loading) return;

      if (this.loading && this.loading.parentNode) {
        this.loading.parentNode.removeChild(this.loading);
      }
    }

    private handleError(error: unknown, pdfUrl: string): void {
      // eslint-disable-next-line no-console
      console.error("Error loading PDF:", error);

      if (this.container) {
        this.container.innerHTML = `
          <div class="p-8 text-center">
            <p class="text-red-500 mb-4">Failed to load PDF</p>
            <a href="${pdfUrl}" download class="text-blue-500 underline hover:text-blue-600">
              Download PDF
            </a>
          </div>
        `;
      }

      if (this.loading) {
        this.loading.style.display = "none";
      }
    }

    handleResize = (): void => {
      // 只在宽度真正变化时才重新渲染（避免移动端滚动时地址栏隐藏/虚拟键盘触发的resize）
      const currentWidth = window.innerWidth;
      if (currentWidth === this.lastWidth) return;
      
      this.lastWidth = currentWidth;
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => this.init(), RESIZE_DEBOUNCE_DELAY);
    };

  }

  // Initialize PDF viewer (singleton pattern)
  let viewer: PDFViewer | null = null;
  let currentResizeHandler: (() => void) | null = null;

  function initViewer() {
    // 清理旧的 viewer 和事件监听器
    if (viewer) {
      viewer.destroy();
    }
    if (currentResizeHandler) {
      window.removeEventListener("resize", currentResizeHandler);
    }

    // 创建新的 viewer 实例
    viewer = new PDFViewer();
    viewer.init();

    // 更新 resize 监听器指向新的 viewer
    currentResizeHandler = viewer.handleResize;
    window.addEventListener("resize", currentResizeHandler);
  }

  // Handle Astro page transitions
  document.addEventListener("astro:page-load", initViewer);
</script>
